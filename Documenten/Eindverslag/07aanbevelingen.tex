\section{Aanbevelingen}
\label{Aanbevelingen}
Hieronder een korte toelichting op werkzaamheden waar wij niet aan toe zijn gekomen. 
Sommige van deze werkzaamheden zijn niet gebeurd omdat ze buiten de scope van het project vielen of tijdens het project bedacht werden. 
In enkele gevallen hadden we wel gepland om het werk te doen maar zijn we er niet aan toe gekomen.  
In de toelichting geven we ook een korte samenvatting van wat er in brainstorm sessies en/of vergaderingen over is afgesproken. 
Wij hopen op deze manier dat toekomstige groepen op een eenvoudige en snelle manier kunnen verder werken aan het product.

\subsection{Bestandstypen van foto's}
Op dit moment kan de morph-functie alleen foto's aan die het bestandstype jpeg hebben. 
Alhoewel dit het meest voorkomende type is zou het een verbetering zijn als het systeem ook met andere typen om kan gaan. 
Een probleem hierbij is, dat de foto's bij het uploaden wel de extensie 'jpg' krijgen, maar het eigenlijk nog geen jpeg foto's zijn. 
Het kan nu bijvoorbeeld gebeuren dat er een gif-afbeelding wordt geupload, die vervolgens de extensie jpg krijgt. 
Hierdoor geeft de vtkJPEGReader een error, en kan er met dit plaatje niet gemorphed worden. 
Het weergeven van de afbeelding in de browser gaat echter wel goed, waardoor het voor de gebruiker niet duidelijk is dat er eigenlijk iets mis is met de afbeelding.

Een oplossing zou kunnen zijn om bij het uploaden van de afbeelding de Python Imaging Library te laten kijken naar de foto, en deze om te laten zetten naar een echt jpeg bestand. 
Het gevaar hierbij is echter, dat er door de compressie van het jpeg formaat het een en ander aan scherpte van de foto verloren gaat.
Een eventuele oplossing voor dit probleem zou kunnen zijn om helemaal geen jpeg-bestanden meer op te slaan, en alle foto's te laten omzetten naar het PNG-formaat. Bij deze omzetting gaat vrijwel geen informatie in de foto verloren, en voor dit formaat zijn dezelfde VTK-library's beschikbaar als voor het jpeg formaat.

Dit is echter een probleem waar wij binnen het project zodanig laat tegenaan liepen, dat er geen tijd meer was om dit op een fatsoenlijke manier op te lossen.

\subsection{Verschillende kleuren in flash applicatie}
Binnen onze applicatie is het op dit moment al mogelijk om een bitmap te tekenen in een willekeurige kleur. 
Wat echter nog niet mogelijk is, is om in \'{e}\'{e}n bitmap meerdere kleuren op te slaan.
Voor de gebruikers zou het echter intu\'{i}tiever zijn om dit wel te kunnen, vooral omdat er bij het tekenen van de bitmap wel met verschillende kleuren gewerkt kan worden.
Het moet de gebruiker dan expliciet verteld worden dat de hele bitmap wordt opgeslagen in de kleur waarmee het laatst is gewerkt.
%TODO voor Bastiaan

\subsection{Opslaan van een lege bitmap}
* alle correcties weggooien en geen wijziging opslaan?
* lege bitmap opslaan?
%TODO voor Bastiaan

\subsection{Te grote foto's inladen in de flash-applicate}
%TODO voor Bastiaan

%titels zijn voorstellen, kunnen gewijzigd worden
\subsection{statistische data bij landmarks}
Een bekende wens vanuit de gebruikers bij het EMC is dat er statistische data opgeslagen kan worden bij de aangegeven landmarks.
Deze data heeft dan bijvoorbeeld betrekking op de diepte waarop een vene op verschillende punten in het been ligt.
In de huidige situatie wordt deze data apart in een Excel-sheet bijgehouden, en naar een statisticus gebracht.
Deze maakt hier vervolgens in aparte software (SPSS) een aantal grafieken van, die de gebruikers eigenlijk bij de andere data op zouden willen slaan.
In de toekomst zou het mogelijk moeten zijn om deze data bij de landmarks zelf op te slaan.
In een ideale situatie zouden zelfs de grafieken in het systeem moeten kunnen verschijnen, waarna de gebruikers van een willekeurig punt op de grafiek de waarde op kunnen vragen.

Vanwege de complexiteit van het opslaan van de statistische data, het later genereren van de bijbehorende grafieken, en het kunnen opvragen van de waardes op een willekeurig punt, hebben wij hier nog geen stappen voor ondernomen.
Een volgende groep zou kunnen beginnen met het enkel toevoegen van de data, en deze overzichtelijk weer te geven, zonder hier grafieken van de maken.
De analyse van deze data, en het hieruit produceren van bruikbare data, is daarna weer een probleem apart, wat zelfs voor een eerste opzet waarschijnlijk een heleboel onderzoek benodigt.
Het enige licht wat wij nu al een beetje op de zaak kunnen laten schijnen, is dat er een PyCha module bestaat, waarmee in Python grafieken gemaakt kunnen worden.

\subsection{uitwerken afstand meet applicatie}
Vanuit het EMC was de wens opgekomen om het mogelijk te maken om in foto's afstanden te meten.
Dit zou dan gebruikt kunnen worden bij een deel van de statistische data, zoals dit hierboven al beschreven is.
Aangezien een van de eerste vragen van het EMC was hebben we hier al even naar gekeken, en een zgn. 'spiky solution' voor gebouwd.
Hier zat echter nog een niet acceptabele meetfout in, waardoor de functie niet in de uiteindelijke interface terecht is gekomen.
Er waren echter wel een aantal manieren waarop de nu aanwezige meetfout waarschijnlijk teruggedrongen kon worden:
\begin{description}
	\item[verplaatsen lineaal] Op de foto's van het EMC is een lineaal zichtbaar. Echter deze lineaal ligt op de verkeerde positie ten op zichte van waar gemeten wordt, er is namelijk een diepte verschil. Ook ligt de lineaal niet recht onder de camera, dit zorgt voor een hoek in de kalibratie stap.
	\item[fout zichtbaar maken] Op dit moment wordt er wel gerekend en wordt de fout op een basis manier uitgerekend. Deze fout zou zichtbaar moeten gemaakt worden aan de gebruiker, zodat hiermee rekening kan worden gehouden.
	\item[opslaan kalibratie] Elke keer als een foto wordt geopend moet de kalibratie stap opnieuw worden uitgevoerd. Hierdoor ontstaat mogelijk onzorgvuldigheid en eigenlijk moet de kalibratie stap worden opgeslagen.
	\item[automatische herkenning] Als we de lineaal kunnen laten herkennen door een algoritme dan kan de kalibratie stap geautomatiseerd worden en wordt de menselijke factor verkleind.
\end{description}

\subsection{uitgebreid user management en arts-view mode}
Wat betreft het huidige user management zijn er nog vele verbeteringen mogelijk.
Momenteel zijn er namelijk 3 gebruikersgroepen aanwezig, die niet altijd evengoed gecontroleerd worden.
Zo is het nu voor een arts ook mogelijk om landmarks toe te voegen aan een project, terwijl dit niet zou moeten mogen.
Ook moet het toekennen van rechten aan projecten beter en duidelijker gaan verlopen.
Daarnaast zou een gebruiker ten alle tijden zijn eigen wachtwoord aan moeten kunnen passen, terwijl dat nu alleen door een 'beheerder' gedaan kan worden.

Zoals al aangegeven is er voor het user management al wel een begin gemaakt, maar dit moet eigenlijk nog uitgebreid worden.
Een deel van deze uitbreiding zou ook in kunnen houden dat er nauwer wordt samengewerkt met de permissions die in Django aan gebruikers toegekend kunnen worden, omdat hier eigenlijk nog niets mee gebeurd.

Zelf zijn wij door tijdsdruk hier niet goed meer aan toegekomen, en is het eigenlijk blijven liggen, ondanks dat een degelijke user management in eerste instantie wel een van de eisen het EMC was.

\subsection{verwijderen measurements e.d. zonder admin}
Wat betreft het verwijderen van een aantal objecten uit het systeem, is er ook nog grote winst te behalen.
Zo wordt voor het verwijderen van de volgende objecten nu nog de Django-admin-interface gebruikt:
\begin{itemize}
  \item Bitmaps
  \item Landmarks
  \item PDMs
  \item Projects
  \item Tags
\end{itemize}
Van deze objecten wordt er nu alleen voor projecten ook de mogelijkheid geboden om deze via de normale interface te verwijderen, terwijl het eigenlijk het netst is, om alle objecten via de interface te kunnen verwijderen.

Toen wij hier zelf over aan het nadenken waren, kwamen wij tot de conclusie dat een aantal oplossingen waren die allemaal eigenlijk niet zo goed ginen werken.
De oplossingen waar wij aan gedacht hebben, staan hier onder beschreven.
\begin{description}
  \item[Inline delete] Een van de mogelijkheden was om in de interface achter elke landmark en elke bitmap een rood kruisje te plaatsen.
  Hier hebben wij vanaf gezien, omdat wij vonden dat de gewone gebruikersinterface dan eigenlijk veel te vol werd.
  Verder staan er eigenlijk nergens in de interface kruisjes, en hebben we overal zogenaamde 'managers' voor
  \item[Bij de image manager] Omdat de landmarks en bitmaps onderdeel zijn van de afbeeldingen, zou het misschien bij de image manager erbij kunnen.
  Dit zou dan in kunnen houden dat er eerst op de afbeelding geklikt moet worden, waarna er een lijstje met landmarks en bitmaps verschijnt die verwijderd kunnen worden.
  Nadeel hiervan is dat de image manager eigenlijk niet de plek is om dit soort dingen in te regelen, omdat hij puur bedoeld is voor de afbeeldingen.
  \item[Delete mode]De radicaalste oplossing was om een 'delete mode' toe te voegen aan de interface.
  Het idee hierbij was dat je op een knop kon drukken, waarna er eigenlijk een nieuwe interface geladen werd.
  In deze nieuwe interface kon je dan eigenlijk alles naar een prullenbak slepen, waarna het verwijderd werd op het moment dat je deze 'delete mode' weer verliet.
  Dit klonk opzich als een heel leuk idee, ware het niet dat dit heel veel tijd zou gaan kosten.
  Daar kwam nog eens bij dat we niet zeker wisten of dit wel een idee was wat aan zou slaan bij de gebruikers, en of dit voor de gebruikers wel echt intu\"{i}tief was.
  \item[Eigen manager] Een eigen manager voor de landmarks en bitmaps was waarschijnlijk het beste idee, maar door de tijdsdruk zijn we ook hier niet aan toe gekomen.
  Het enige wat eigenlijk tegen was op deze oplossing was het feit dat er dan nog een link bij zou komen in de interface.
  Gekscherend werd er gezegd dat er bijna behoefte was aan een manager voor de managers, omdat het er inmiddels al zo veel zijn.
\end{description}

\subsection{morphen naar standaard AnatomicalView}
%TODO: NOESKA

\subsection{zoom op meerdere niveau's}
Een leuke en handige uitbreiding voor de nu aanwezige zoom-functie in de interface, is om het niveau van de zoom in te kunnen stellen.
In het zoom scherm wordt het huidige plaatje nu twee keer zo groot weergegeven als dat het in werkelijkheid eigenlijk is, maar idealiter is dit in te stellen naar een willekeurige grootte.
Om dit te bereiken is het wellicht het makkelijkst om te beginnen met het zoomen op een aantal vastgestelde niveau's, zoals 150\%, 200\%, 250\% en 300\%.
Dit kan dan later altijd nog uitgebreid worden naar een de gebruiker in te stellen niveau, binnen een aantal vastgestelde grenzen.

De reden waarom wij dit nog niet hebben aangepakt, is dat het voor ons een te groot project zou worden.
Ook zitten er aan de huidige implementatie nog wat haken en ogen voordat het op deze manier kan werken, omdat nu het huidige plaatje in zijn geheel op 200\% wordt ingeladen in dat frame.
Als je dit uit gaat breiden naar een aantal vast niveau's is het misschien wat betreft de load nog wel haalbaar de afbeelding op deze niveau's alvast op te halen, maar voor een willekeurig niveau is dit onhaalbaar.
Een ander alternatief is om de afbeelding met het gewenste zoomniveau op te halen nadat het niveau is ingesteld door de gebruiker.
Het nadeel hiervan is dat \'{e}\'{e}n afbeelding dan heel vaak opgehaald moet worden, voordat de gebruiker het gewenste niveau heeft gevonden.
Een derde optie was om de afbeelding zichzelf te laten vergroten in het zoom-kader, afhankelijk van het niveau. 
Het grote nadeel van deze oplossing was dat een afbeelding momenteel wordt ingeladen met een grote die afhankelijk is van de grote van zijn container.
Als deze dus klein is, wordt er standaard een foto met heel weinig detail ingeladen.

\subsection{schaalweergave in image}

\subsection{export on unix import on windows}
